\documentclass[oneside]{article}
\usepackage[margin=1in]{geometry}
\usepackage{mathpazo}

\begin{document}
\title{Milestone 2}
\author{Guillaume Labranche \and William Bain \and Si Mei Zhang}
\maketitle

\tableofcontents

\section{Design decisions}

\subsection{Typechecker}

We implemented the typechecker as a subclass of the \verb|DepthFirstAdapter| class provided by SableCC. This made it easy to traverse the AST without extra boilerplate. Since we did not have a reliable way of editing the extending the AST classes generated by SableCC, we stored type information for the AST in a hash table mapping from nodes to Go types.\footnote{By extending I mean adding methods and properties to a class used by the parser (here probably \texttt{PExp}, the abstract expression production class), not just creating a subclass.}

In most cases it was sufficient to apply typechecks after the the typechecker had recursed over the child nodes and typechecked them. There were two cases where more fine-grained control was necessary:

\begin{itemize}
    \item In short assignment statements, the list of variables is implemented as a list of expressions for reasons having to do with the parser implementation. It was therefore necessary to stop the typechecker from typechecking the variables before they had been added to the symbol table.
    \item To typecheck function declarations, it was necessary to open a scope after having typechecked some but not all of the child nodes.
\end{itemize}

In each of these special cases we overrode the \verb|case| method which controls the recursion over the child nodes.

A further implementation detail that is worth noting is our implementation of struct type declarations. To prevent code duplication, we treat struct fields as if they were variable declarations: we open a scope in the symbol table upon entering the struct and enter each field as if it were a variable. Then we pop the scope and use it to build the struct class.

\subsection{Type and symbol class hierarchy}

TODO (put the UML diagram here)

\subsection{Symbol table}

TODO

\subsection{Typed pretty printer}

We extended the \verb|PrettyPrinter| class we implemented in Milestone 1 to have it print extra type information. By overriding the \verb|defaultOut| method, it was simple to have it look up and output the type of any node which is an instance of the \verb|PExp| (expression production) class as an inline comment.

\section{Scoping rules}

TODO

\section{Type check operations}

TODO

\section{Breakdown of major contributions}

\begin{description}
    \item[Guillaume Labranche] Type checker architecture, symbol table implementation, type checker implementation (especially toplevel declarations and types)
    \item[William Bain] Type checker architecture, command-line interface, type checker implementation (especially expressions and types)
    \item[Si Mei Zhang] Type checker implementation (especially statements), test programs
\end{description}

\end{document}
