//import Interpreter; 
import golite.parser.* ; 
import golite.lexer.* ; 
import golite.node.* ; 
import golite.analysis.* ; 

import java.io.PrintWriter;
import java.io.Writer;
import java.lang.System; 
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class PrettyPrinter extends DepthFirstAdapter {
	static String indent = "\t";
	StringBuilder prepend = new StringBuilder("");
	PrintWriter output;
	
	public PrettyPrinter(PrintWriter writer) {
		output = writer;
	}
	
	private void p(String text) {
		output.print(text);
	}
	private void pln(String text) {
		startl();
		p(text);
		endl();
	}
	
	private void shift() {
		prepend.append(indent);
	}
	private void unshift() {
        prepend.delete(0, indent.length());
	}
	
	private void startl() {
		p(prepend.toString());
	}
	
	private void endl() {
		p("\n");
	}
	
	//start: program
	public void caseAProgram(AProgram node){
		pln("/*The content is generated by pretty printer.*/");
		pln("Package" + node.getPackageName().getText()+";");
	
		PDeclaration[] listDecl = (PDeclaration[])node.getDeclarations().toArray(new PDeclaration[0]);
		for(int i=0; i<listDecl.length; i++)
		{
			listDecl[i].apply(this);
			//pln(null);
		}
		endl();
	}

	//declaration:
	public void caseAVariableDeclaration(AVariableDeclaration node)
	{
		PVariableSpec[] list = (PVariableSpec[])node.getVariableSpec().toArray(new PVariableSpec[0]);
		for(int i=0; i<list.length; i++)
		{
			list[i].apply(this);
		}
	}
	
	public void caseATypeDeclaration(ATypeDeclaration node)
	{
		//??? P or A
		PTypeSpec[] listTypeSpec = (PTypeSpec[])node.getTypeSpec().toArray(new ATypeSpec[0]);
		for(int i=0; i<listTypeSpec.length; i++)
		{
			listTypeSpec[i].apply(this);
		}
	}
	
	public void inAFunctionDeclaration(AFunctionDeclaration node)
	{
		p("func " + node.getId().getText() + " (");
		
		AFuncParam[] listFunc = (AFuncParam[])node.getFuncParam().toArray(new AFuncParam[0]);
		for(int i=0; i<listFunc.length; i++)
		{
			listFunc[i].apply(this);
		}			
		p(" )");
		
		if (node.getReturnType()!=null) {
			node.getReturnType().apply(this);
		} 
		p("{\n");
		
		PStm[] listStm = (PStm[])node.getStm().toArray(new PStm[0]);
		for(int j=0; j<listStm.length; j++)
		{
			listStm[j].apply(this);
			p("\n");
		}	
		
		pln("}");
	}
	
		//variable_spec: 
		
	public void caseAEmptyDeclaration(AEmptyDeclaration node){}
	
	public void caseATypedVariableSpec(ATypedVariableSpec node)
	{
		//{typed} id+ type_exp exp*
	    	Iterator<TId> iter = node.getId().iterator();
	    	while (iter.hasNext()){
			  TId s = (TId)iter.next();
			  p(" " + s.getText());
	    	}
	    	node.getTypeExp().apply(this);
	    		
	       	PExp[] listExp = node.getExp().toArray(new PExp[0]);
	       	for(int i=0; i<listExp.length; i++) {
	       	listExp[i].apply(this);
	       	}
	}
		
	public void caseAUntypedVariableSpec(AUntypedVariableSpec node)
	{
		//???{untyped} id+ exp+	
		Iterator<TId> iter = node.getId().iterator();
		while (iter.hasNext()){
		  TId s = iter.next();
		  p(s.getText()+ " ");
		}

		Iterator<PExp> iter2 = node.getExp().iterator();
		while (iter2.hasNext()){
			PExp e = iter2.next();
			e.apply(this);
		}
	}
	
	//type_spec = id type_exp;
	public void caseATypeSpec(ATypeSpec node)
	{
		p(node.getId().getText()+" "); 
		node.getTypeExp().apply(this);
	}
		
	//func_param = id+ type_exp;
	public void caseAFuncParam (AFuncParam node)
	{
		//{typed} id+ type_exp exp*
		TId[] listId = (TId[])node.getId().toArray(new TId[0]);
		for(int i=0; i<listId.length - 1; i++)
		{
			p(listId[i].getText()+",");
		}
		listId[listId.length].getText();
		
		node.getTypeExp().apply(this);
	}
		
		//type_exp : 
	public void inAAliasTypeExp(AAliasTypeExp node)
	{
		p(node.getId().getText());
	}
	
	public void inAIntTypeExp(AIntTypeExp node)
	{
		p(" int");
	}
	
	public void inAFloat64TypeExp(AFloat64TypeExp node){
		p(" float64");
	}
	
	public void inABoolTypeExp(ABoolTypeExp node)
	{
		p(" bool");
	}
	    
	public void inARuneTypeExp(ARuneTypeExp node)
	{
		p(" rune");
	}

    	public void inAStringTypeExp(AStringTypeExp node)
    	{
    		p(" string");
    	}

    	//type person struct {
        //name string
        //age  int
        //}
    	public void caseAStructTypeExp(AStructTypeExp node)
    	{
    		p("struct{\n");
    		inAStructTypeExp(node);
   
    		AFieldDec[] list = (AFieldDec[])node.getFieldDec().toArray(new AFieldDec[0]);
    		for(int i=0; i<list.length ; i++)
    		{
    			list[i].apply(this);
    			p("\n");
    		}
    		pln("}");
    	}
    
    	//slice:  var a [] int
    	public void caseASliceTypeExp(ASliceTypeExp node)
    	{
    		p("[]");
    		node.getTypeExp().apply(this);
    		p("\n");
    	}
    
    	//example: var a [5] int
    	public void caseAArrayTypeExp(AArrayTypeExp node)
    	{	
    		p(" [" + node.getLitInt().getText() + "]");
        	node.getTypeExp().apply(this);
        	p("\n");
    	}
    	
    	//field_dec
    	public void caseAFieldDec(AFieldDec node)
    	{
    		TId[] listId = (TId[])node.getId().toArray(new TId[0]);
			for(int i=0; i<listId.length - 1; i++)
			{
				p(listId[i].getText()+",");
			}
			listId[listId.length].getText();
			
        	node.getTypeExp().apply(this);

    	}
    	
    	//stm
    	public void caseAEmptyStm (AEmptyStm node) {}
  
    	public void caseAExpressionStm (AExpressionStm node)
    	{
    		node.getExp().apply(this);
    		p(";\n");
    	}
    
    	public void caseAAssignStm (AAssignStm node)
    	{
    		
    		PExp[] listId = (PExp[])node.getLvalue().toArray(new PExp[0]);
    		PExp[] listId2 = (PExp[])node.getExp().toArray(new PExp[0]);
    		
			for(int i=0; i<listId.length - 1; i++)
			{
	    		listId[i].apply(this);
	    		p(",");
				listId2[i].apply(this);
			}
			listId[listId.length].apply(this);
			listId2[listId2.length].apply(this);
    	}
 
    	public void caseAOpAssignStm (AOpAssignStm node)
    	{
    		node.getLvalue().apply(this);
    		node.getAssignOp().apply(this);
    		node.getExp().apply(this);
    	}

    	public void caseAIncDecStm (AIncDecStm node)
    	{
    		node.getExp().apply(this);
    		node.getPostfixOp().apply(this);
    		p("\n");
    	}
        
        public void caseAShortVariableDecStm (AShortVariableDecStm node)
        {
        	List<PExp> list1 = new ArrayList<PExp>(node.getIds());
        	for(PExp v:list1)
        	{
        		v.apply(this);
        	}
        	p(":=");
        	
			Iterator<PExp> iter = node.getExp().iterator();
			while (iter.hasNext()){
				PExp e = iter.next();
				e.apply(this);
			}
        }
	
    	public void caseAVariableDecStm (AVariableDecStm node)
    	{
     		List<PVariableSpec> listVar = new ArrayList<PVariableSpec>(node.getVariableSpec());
        
     		for(PVariableSpec v : listVar)
        	{
        	v.apply(this);
        	} 
    	}

    	public void caseATypeDecStm (ATypeDecStm node)
    	{
    		//type_spec+
    		Iterator<PTypeSpec> iter = node.getTypeSpec().iterator();
    		while (iter.hasNext()){
			PTypeSpec t = (PTypeSpec)iter.next();
			t.apply(this);
    		} 
    	}
    
    	public void caseAPrintStm (APrintStm node)
    	{
    		
    		node.getPrintOp().apply(this);
    		if(node.getExp()!= null)
        	{
    	 	//exp*
			PExp[] listExp = (PExp[])node.getExp().toArray(new PExp[0]);
			for(int i=0; i<listExp.length - 1; i++)
			{
				listExp[i].apply(this);
				p(",");
			}
			listExp[listExp.length].apply(this);
        	}
        	
        	p(")\n");
    	}
    
    	public void caseAReturnStm (AReturnStm node)
    	{
    		if (node.getExp()!=null){
    		node.getExp().apply(this);
    		}
    	}
    
    	public void caseAIfStm (AIfStm node)
    	{
    		p("if ");
    		if (node.getStm()!=null){
    			node.getStm().apply(this);
    		}
    		node.getExp().apply(this);
    		
    		{ 
    	List<PStm> if_copy = new ArrayList<PStm>(node.getIfBlock());
            		boolean ifblock=false;
            		if (if_copy.size()>1){
            			ifblock=true;
            		} else {}   
            
            		for(PStm s : if_copy)
            		{
                		s.apply(this);
            		}
	            	if (ifblock==true) {	
            		} else {};
            	}            
    		{  
            	List<PStm> else_copy = new ArrayList<PStm>(node.getElseBlock());
            	boolean elseblock=false;
            	if (else_copy.size()>1){
            		elseblock=true;
            	} else {}   
            
            	for(PStm s : else_copy)
            	{
                	s.apply(this);
            	}
            	if (elseblock==true) {
                } else {}
            }            
    }
    
	public void caseASwitchStm (ASwitchStm node)
    	{
    		if (node.getStm()!=null)
    		{
    		node.getStm().apply(this);
    		}
    		if (node.getExp()!=null)
    		{
    		p("switch");
    		node.getExp().apply(this);
    		p("{\n")
    		}
    		//switch_clause*
		PSwitchClause[] listSwitch = (PSwitchClause[])node.getSwitchClause().toArray(new PSwitchClause[0]);
		for(int i=0; i<listSwitch.length; i++)
		{
			
			listSwitch[i].apply(this);
		}
    	}
    
	public void caseAForStm(AForStm node)
	{
		if(node.getInit()!= null){
			node.getInit().apply(this);
		}
    		
		if(node.getPost()!= null){
			node.getPost().apply(this);
		}
    		
		//stm*
		Iterator<PStm> iter = node.getStm().iterator();
		while (iter.hasNext()){
			PStm p = (PStm)iter.next();
			p.apply(this);
		} 
	}
    
	public void caseABreakStm(ABreakStm node){}
	public void caseAContinueStm (AContinueStm node){}
    
	 //???switch_clause = {conditional} exp+ stm* | {default} stm*;
	public void caseAConditionalSwitchClause(AConditionalSwitchClause node)
	{
		
		PExp[] listExp = (PExp[])node.getExp().toArray(new PExp[0]);
		for(int i=0; i<listExp.length; i++)
		{
			listExp[i].apply(this);
			p(",");
		}
		
		PStm[] listStm = (PStm[])node.getStm().toArray(new PStm[0]);
		for(int i=0; i<listStm.length; i++)
		{
			listStm[i].apply(this);
			p("\n");
		}
	}
    
	public void caseADefaultSwitchClause(ADefaultSwitchClause node)
	{
		p("default:");
		PStm[] listStm = (PStm[])node.getStm().toArray(new PStm[0]);
		for(int i=0; i<listStm.length; i++)
		{
			listStm[i].apply(this);
			p("\n");
		}
		
		if (node.getFallthroughStm()!=null)
		{
			node.getFallthroughStm().apply(this);	
		}
	}
    
	//print_op:
	public void caseASimplePrintOp(ASimplePrintOp node)
	{
    		p("print (");
	}
    
	public void caseALinePrintOp(ALinePrintOp node)
	{
		p ("println (");
	}   
    
	//postfix_op:
	public void caseAIncPostfixOp(AIncPostfixOp node)
	{
		p("++");
	}
    
	public void caseADecPostfixOp(ADecPostfixOp node)
	{
		p("--");
	}
    
	//assign_op:
	public void caseAPlusAssignOp(APlusAssignOp node)
	{
		p("+");
	}
    
	public void caseAMinusAssignOp(AMinusAssignOp node)
	{
		p("-");
	}
    
	public void caseAStarAssignOp(AStarAssignOp node)
	{
		p("*");
	}
    
	public void caseASlashAssignOp(ASlashAssignOp node)
	{
		p("/");
	}
    
	public void caseAPercentAssignOp(APercentAssignOp node)
	{
		p("%");
	}   
    
	public void caseAAmpAssignOp(AAmpAssignOp node)
	{
		p("&");
	}
	
	public void caseAPipeAssignOp(APipeAssignOp node)
	{
		p("|");
	}
	
	public void caseACaretAssignOp(ACaretAssignOp node)
	{
		p("^");
	}    
    
	public void caseALshiftAssignOp(ALshiftAssignOp node)
	{
		p("<<");
	}    
    
	public void caseARshiftAssignOp(ARshiftAssignOp node)
	{
		p(">>");
	}     
    
	public void caseAAmpCaretAssignOp(AAmpCaretAssignOp node)
	{
		p("&^");
	}       
    
    	//binary_op
    	public void caseALogicalOrBinaryOp(ALogicalOrBinaryOp node)
    	{
    		p("||");
    	}
    	
    	public void caseALogicalAndBinaryOp(ALogicalAndBinaryOp node)
    	{
    		p("&&");
    	}
    	
    	public void caseAEqBinaryOp(AEqBinaryOp node)
    	{
    		p("==");
    	}    	
 
     	public void caseAGtBinaryOp(AGtBinaryOp node)
    	{
    		p(">");
    	}

    	public void caseALtBinaryOp(ALtBinaryOp node)
    	{
    		p("<");
    	}

    	public void caseAGtEqBinaryOp(AGtEqBinaryOp node)
    	{
    		p(">=");
    	}
    	
    	public void caseALtEqBinaryOp(ALtEqBinaryOp node)
    	{
    		p("<=");
    	}

	public void caseAPlusBinaryOp(APlusBinaryOp node)
	{
		p("+");
	}
	    
	public void caseAMinusAssignOp(AMinusBinaryOp node)
	{
		p("-");
	}
	    
	public void caseAStarBinaryOp(AStarBinaryOp node)
	{
		p("*");
	}
	    
	public void caseASlashBinaryOp(ASlashBinaryOp node)
	{
		p("/");
	}
	    
	public void caseAPercentBinaryOp(APercentBinaryOp node)
	{
		p("%");
	}   
	    
	public void caseAAmpBinaryOp(AAmpBinaryOp node)
	{
		p("&");
	}
	
	public void caseAPipeBinaryOp (APipeBinaryOp node)
	{
		p("|");
	}
	
	public void caseACaretBinaryOp(ACaretBinaryOp node)
	{
		p("^");
	}    
	    
	public void caseALshiftBinaryOp(ALshiftBinaryOp node)
	{
		p("<<");
	}    
	    
	public void caseARshiftBinaryOp(ARshiftBinaryOp node)
	{
		p(">>");
	}     
	    
	public void caseAAmpCaretBinaryOp(AAmpCaretBinaryOp node)
	{
		p("&^");
	} 
	
	//unary_op
	public void caseAPlusUnaryOp(APlusUnaryOp node)
	{
		p("+");
	}
	
	public void caseAMinusUnaryOp(AMinusUnaryOp node)
	{
		p("-");	
	}
	   
	public void caseAExclamationUnaryOp(AExclamationUnaryOp node)
	{
		   	p("!");	
	}
	    
	public void caseACaretUnaryOp(ACaretUnaryOp node)
	{
		p("^");	
	}
	
	//exp:
	public void caseAVariableExp(AVariableExp node)
	{
		p(node.getId().getText());
	}   
	    
	public void caseAArrayAccessExp(AArrayAccessExp node)
	{
	    	node.getArray().apply(this);
	    	node.getIndex().apply(this);
	}
	    	
	public void caseAFieldAccessExp(AFieldAccessExp node)
	{
	   	node.getExp().apply(this);
	    	p(" " + node.getId().getText());
	}    	
	    	
	public void caseALitIntExp(ALitIntExp node)
	{
		p(node.getLitInt().getText());
	}    
	    
	public void caseALitFloatExp(ALitFloatExp node)
	{
		p(node.getLitFloat().getText());
	} 
		
	public void caseALitHexExp(ALitHexExp node)
	{
		p(node.getLitHex().getText());
	}    
		
	public void caseALitOctalExp(ALitOctalExp node)
	{
		p(node.getLitOctal().getText());
	}    
	
	public void caseALitInterpretedExp(ALitInterpretedExp node)
	{
		p(node.getLitInterpreted().getText());
	}    
		
	public void caseALitRawExp(ALitRawExp node)
	{
		p(node.getLitRaw().getText());
	}    
		
	public void caseALitRuneExp(ALitRuneExp node)
	{
		p(node.getLitRune().getText());
	}    
		
	public void caseAFunctionCallExp(AFunctionCallExp node)
	{
		p(node.getId().getText());
		//exp*
		PExp[] listExp = (PExp[])node.getExp().toArray(new PExp[0]);
		for(int i=0; i<listExp.length; i++)
		{
			listExp[i].apply(this);
		}
	}                       	
		
	public void caseABaseTypeCastExp(ABaseTypeCastExp node)
	{
		node.getTypeExp().apply(this);
		node.getExp().apply(this);
	}    
	
	public void caseAAppendExp(AAppendExp node)
	{
		p(node.getId().getText() + " ");
		node.getExp().apply(this);
	} 	
		
	public void caseABinaryExp(ABinaryExp node)
	{
		//[left]:exp binary_op [right]:exp
		node.getLeft().apply(this);
		node.getBinaryOp().apply(this);
		node.getRight().apply(this);
	} 
		
	public void caseAUnaryExp(AUnaryExp node)
	{
		node.getUnaryOp().apply(this);
		node.getExp().apply(this);
	} 
}
