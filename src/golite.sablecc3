Package golite;

/* https://golang.org/ref/spec */

Helpers
	/* regular expression matching all valid 16-bit characters */
	/*any = [0..0xFFFF];*/
	all = [0..127];
 	tab   = 9;
	cr    = 13;
	lf    = 10;
	eol   = cr | lf | cr lf;
	not_eol = [all - [cr + lf]];
	not_star = [all - '*'];
	not_backslash = [all - '\'];
	not_star_slash = [not_star - '/'];
	
	quote_single = ''';
	quote_double = '"';
	quote_back = '`';
	
	digit_nonzero = ['1'..'9'];
	digit_decimal = ['0'..'9'];
	digit_octal = ['0'..'7'];
	digit_hex = ['0'..'9'] | ['A'..'F'] | ['a'..'f'];
	
	letter_lc = ['a'..'z'];
	letter_uc = ['A'..'Z'];
	letter  = letter_lc | letter_uc | '_';
	
	/*char_literal = [all - [eol + '\']];*/ /* disallow backslash, then allow appropriate escape sequences */
	char_escape = '\' ( 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\' );
	char_escape_sq = '\' ''';
	char_escape_dq = '\"';

Tokens
	whitespace = (' ' | tab | eol)+;
	
	/* Keywords */
	import = 'import';
	package = 'package';
	chan = 'chan';
	const = 'const';
	default = 'default';
	defer = 'defer';
	var = 'var';
	type = 'type';
	struct = 'struct';
	interface = 'interface';
	func = 'func';
	return = 'return';
	if = 'if';
	else = 'else';
	switch = 'switch';
	case = 'case';
	goto = 'goto';
	for = 'for';
	break = 'break';
	continue = 'continue';
	fallthrough = 'fallthrough';
	go = 'go';
	map = 'map';
	range = 'range';
	select = 'select';
	print = 'print';
	append = 'append';
	println = 'println';
	bool = 'bool';
	int = 'int';
	float64 = 'float64';
	rune = 'rune';
	string = 'string';
	
	/* Operators and Delimiters
	 * in order from the specs (easier to spot a missing one) */
	plus = '+';
	minus = '-';
	star = '*';
	slash = '/';
	percent = '%';
	amp = '&';
	pipe = '|';
	caret = '^';
	lshift = '<<';
	rshift = '>>';
	amp_caret = '&^';
	plus_eq = '+=';
	minus_eq = '-=';
	star_eq = '*=';
	slash_eq = '/=';
	percent_eq = '%=';
	amp_eq = '&=';
	pipe_eq = '|=';
	caret_eq = '^=';
	lshift_eq = '<<=';
	rshift_eq = '>>=';
	amp_caret_eq = '&^=';
	amp_amp = '&&';
	bar_bar = '||';
	larrow = '<-';
	plus_plus = '++';
	minus_minus = '--';
	eq_eq = '==';
	lt = '<';
	gt = '>';
	eq = '=';
	exclamation = '!';
	not_eq = '!=';
	lt_eq = '<=';
	gt_eq = '>=';
	colon_eq = ':=';
	elipsis = '...';
	paren_l = '(';
	paren_r = ')';
	square_l = '[';
	square_r = ']';
	brace_l = '{';
	brace_r = '}';
	comma = ',';
	dot = '.';
	semicolon = ';';
	colon = ':';
	
	/* Comments */
	comment = ('//' not_eol* eol)
				| ('/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/');

	/* Literals */
	lit_int  = '0' | digit_nonzero digit_decimal*;
	lit_octal = '0' digit_octal+;
	lit_hex = '0x' digit_hex+;
	lit_float = ('0' | digit_nonzero digit_decimal*)? '.' digit_decimal*;
	lit_rune = quote_single ([all - '\'] | char_escape | char_escape_sq)  quote_single;
	lit_raw = quote_back [all - quote_back]*  quote_back;
	lit_interpreted = quote_double ([all - quote_back] | char_escape | char_escape_dq)* quote_double;
	
	/* Identifiers*/
	id = letter (letter | digit_decimal)*;

Ignored Tokens
	whitespace, comment; /*_line, comment_block;*/

Productions
	program = package_dec declaration* {-> New program(package_dec.id, [declaration])};

	package_dec {-> id} = package id semicolon {-> id};

	declaration =
		  {variable} var variable_specs semicolon
		  		{-> New declaration.variable([variable_specs.variable_spec])}
		| {type} type type_specs semicolon
				{-> New declaration.type([type_specs.type_spec])}
		| {function} func id func_arg_spec brace_l  stm* brace_r
				{-> New declaration.function(id, [func_arg_spec.func_param], [stm])}
	;

	/* Variable declarations */
	variable_specs {-> variable_spec*} =
				  {single_spec} variable_spec {-> [variable_spec]}
				| {multi_spec} paren_l variable_spec_with_semicolon* paren_r
						{-> [variable_spec_with_semicolon.variable_spec]}
	;

	variable_spec_with_semicolon {-> variable_spec} = variable_spec semicolon {-> variable_spec};

	variable_spec =
				  {no_expr} id_list type_exp
						{-> New variable_spec.typed([id_list.id], type_exp, [])}
				| {with_expr} id_list type_exp eq exp_list
						{-> New variable_spec.typed([id_list.id], type_exp, [exp_list.exp])}
				| {with_expr_no_type} id_list eq exp_list
						{-> New variable_spec.untyped([id_list.id], [exp_list.exp])}
	;

	id_list {-> id*} = id id_list_tail* {-> [id, id_list_tail.id]};

	id_list_tail {-> id} = comma id {-> id};

	exp_list {-> exp*} = exp exp_list_tail* {-> [exp, exp_list_tail.exp]};

	exp_list_tail {-> exp} = comma exp {-> exp};

	/* Type declarations */
	type_specs {-> type_spec*} =
		  {single_spec} type_spec {-> [type_spec]}
		| {multi_spec} paren_l type_spec_with_semicolon* paren_r {-> [type_spec_with_semicolon.type_spec]}
	;

	type_spec_with_semicolon {-> type_spec} = type_spec semicolon {-> type_spec};

	type_spec = id type_exp;

	/* Function declarations */
	func_arg_spec {-> func_param*} =
		  {nonempty} paren_l func_param func_param_list_tail* paren_r
				{-> [func_param, func_param_list_tail.func_param]}
		| {empty} paren_l paren_r {-> []}
	;

	func_param = id_list type_exp {-> New func_param([id_list.id], type_exp)};

	func_param_list_tail {-> func_param} = comma func_param {-> func_param};

	variable_spec_list_tail {-> variable_spec} = comma variable_spec {-> variable_spec};

	type_exp =
		  {alias}   id                       {-> New type_exp.alias(id)}
		| {int}     int                      {-> New type_exp.int()}
		| {float64} float64                  {-> New type_exp.float64()}
		| {bool}    bool                     {-> New type_exp.bool()}
		| {rune}    rune                     {-> New type_exp.rune()}
		| {string}  string                   {-> New type_exp.string()}
		| {struct}  struct brace_l type_spec_with_semicolon* brace_r
                                             {-> New type_exp.struct([type_spec_with_semicolon.type_spec])}
		| {slice}   square_l square_r type_exp {-> New type_exp.slice(type_exp)}
		| {array}   square_l lit_int square_r type_exp
                                             {-> New type_exp.array(lit_int, type_exp)}
		| {recurse} paren_l type_exp paren_r   {-> type_exp}
	;

	/* Statements */
	stm = exp;

	exp =
		  {variable} id
		| {lit_int} lit_int
		| {lit_float} lit_float
	;

Abstract Syntax Tree
	program = [package_name]:id [declarations]:declaration*;

	declaration =
		  {variable} variable_spec*
		| {type} type_spec*
		| {function} id func_param* stm*
	;

	variable_spec =
		  {typed} id+ type_exp exp*
		| {untyped} id+ exp+
	;

	type_spec = id type_exp;

	func_param = id+ type_exp;

	type_exp =
		  {alias} id
		| {int}
		| {float64}
		| {bool}
		| {rune}
		| {string}
		| {struct} type_spec*
		| {slice} type_exp
		| {array} lit_int type_exp
	;

	stm = exp;

	exp =
		  {variable} id
		| {lit_int} lit_int
		| {lit_float} lit_float
	;
