Package golite;

Helpers
	/* regular expression matching all valid 16-bit characters */
	any = [0..0xFFFF];
 	tab   = 9;
	cr    = 13;
	lf    = 10;
	eol   = cr | lf | cr lf;
	blank = (' ' | tab | eol)+;
	digit = ['0'..'9'];
	lowercase = ['a'..'z'];
	uppercase = ['A'..'Z'];
	letter  = lowercase | uppercase;
	idletter = letter | '_';
	idchar  = letter | '_' | digit;

Tokens
	/* Characters */
	blank = blank;
	pound = '#';
	ampersand = '&';
	vertbar = '|';
	hat   = '^';
	star  = '*';
	fslash = '/';
	bslash = '\';
	plus  = '+';
	minus = '-';
	percent = '%';
	equal = '=';
	colon = ':';
	semicolon = ';';
	comma = ',';
	anglel = '<';
	angler = '>';
	parenl = '(';
	parenr = ')';
	squarel = '[';
	squarer = ']';
	curlyl = '{';
	curlyr = '}';

	int_lit  = '0' | [digit-'0'] digit*;
	float_lit = ('0' | [digit-'0'] digit*) '.' digit+;

	/* Keywords */
	import = 'import';
	package = 'package';
	chan = 'chan';
	const = 'const';
	default = 'default';
	defer = 'defer';
	var = 'var';
	type = 'type';
	struct = 'struct';
	interface = 'interface';
	func = 'func';
	return = 'return';
	if = 'if';
	else = 'else';
	switch = 'switch';
	case = 'case';
	goto = 'goto';
	for = 'for';
	break = 'break';
	continue = 'continue';
	fallthrough = 'fallthrough';
	go = 'go';
	map = 'map';
	range = 'range';
	select = 'select';
	print = 'print';
	append = 'append';
	println = 'println';
	bool = 'bool';
	int = 'int';
	float64 = 'float64';
	rune = 'rune';
	string = 'string';

	/* Comments */

	commentl = '#' [any-lf]* eol;
	commentb= '/*' any* '*/';

	/* Literals */

	/* Identifiers*/
	id = idletter idchar*;


Ignored Tokens
	blank, commentl, commentb;

Productions
	program = package_dec declaration* {-> New program(package_dec.id, [declaration])};

	package_dec {-> id} = package id semicolon {-> id};

	declaration =
		  {variable} var variable_specs semicolon
		  		{-> New declaration.variable([variable_specs.variable_spec])}
		| {type} type type_specs semicolon
				{-> New declaration.type([type_specs.type_spec])}
		| {function} func id func_arg_spec curlyl  stm* curlyr
				{-> New declaration.function(id, [func_arg_spec.func_param], [stm])}
	;

	/* Variable declarations */
	variable_specs {-> variable_spec*} =
				  {single_spec} variable_spec {-> [variable_spec]}
				| {multi_spec} parenl variable_spec_with_semicolon* parenr {-> [variable_spec_with_semicolon.variable_spec]}
	;

	variable_spec_with_semicolon {-> variable_spec} = variable_spec semicolon {-> variable_spec};

	variable_spec =
				  {no_expr} id_list type_exp {-> New variable_spec.typed([id_list.id], type_exp, [])}
				| {with_expr} id_list type_exp equal exp_list {-> New variable_spec.typed([id_list.id], type_exp, [exp_list.exp])}
				| {with_expr_no_type} id_list equal exp_list {-> New variable_spec.untyped([id_list.id], [exp_list.exp])}
	;

	id_list {-> id*} = id id_list_tail* {-> [id, id_list_tail.id]};

	id_list_tail {-> id} = comma id {-> id};

	exp_list {-> exp*} = exp exp_list_tail* {-> [exp, exp_list_tail.exp]};

	exp_list_tail {-> exp} = comma exp {-> exp};

	/* Type declarations */
	type_specs {-> type_spec*} =
		  {single_spec} type_spec {-> [type_spec]}
		| {multi_spec} parenl type_spec_with_semicolon* parenr {-> [type_spec_with_semicolon.type_spec]}
	;

	type_spec_with_semicolon {-> type_spec} = type_spec semicolon {-> type_spec};

	type_spec = id type_exp;

	/* Function declarations */
	func_arg_spec {-> func_param*} =
		  {nonempty} parenl func_param func_param_list_tail* parenr
				{-> [func_param, func_param_list_tail.func_param]}
		| {empty} parenl parenr {-> []}
	;

	func_param = id_list type_exp {-> New func_param([id_list.id], type_exp)};

	func_param_list_tail {-> func_param} = comma func_param {-> func_param};

	variable_spec_list_tail {-> variable_spec} = comma variable_spec {-> variable_spec};

	type_exp =
		  {alias}   id                       {-> New type_exp.alias(id)}
		| {int}     int                      {-> New type_exp.int()}
		| {float64} float64                  {-> New type_exp.float64()}
		| {bool}    bool                     {-> New type_exp.bool()}
		| {rune}    rune                     {-> New type_exp.rune()}
		| {string}  string                   {-> New type_exp.string()}
		| {struct}  struct curlyl type_spec_with_semicolon* curlyr
                                             {-> New type_exp.struct([type_spec_with_semicolon.type_spec])}
		| {slice}   squarel squarer type_exp {-> New type_exp.slice(type_exp)}
		| {array}   squarel int_lit squarer type_exp
                                             {-> New type_exp.array(int_lit, type_exp)}
		| {recurse} parenl type_exp parenr   {-> type_exp}
	;

	/* Statements */
	stm = exp;

	exp =
		  {variable} id
		| {int_lit} int_lit
		| {float_lit} float_lit
	;

Abstract Syntax Tree
	program = [package_name]:id [declarations]:declaration*;

	declaration =
		  {variable} variable_spec*
		| {type} type_spec*
		| {function} id func_param* stm*
	;

	variable_spec =
		  {typed} id+ type_exp exp*
		| {untyped} id+ exp+
	;

	type_spec = id type_exp;

	func_param = id+ type_exp;

	type_exp =
		  {alias} id
		| {int}
		| {float64}
		| {bool}
		| {rune}
		| {string}
		| {struct} type_spec*
		| {slice} type_exp
		| {array} int_lit type_exp
	;

	stm = exp;

	exp =
		  {variable} id
		| {int_lit} int_lit
		| {float_lit} float_lit
	;
