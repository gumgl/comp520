Package golite;

/* https://golang.org/ref/spec */

Helpers
	/* regular expression matching all valid 16-bit characters */
	/*any = [0..0xFFFF];*/
	all = [0..127];
 	tab   = 9;
	cr    = 13;
	lf    = 10;
	eol   = cr | lf | cr lf;
	not_eol = [all - [cr + lf]];
	not_star = [all - '*'];
	not_backslash = [all - '\'];
	not_star_slash = [not_star - '/'];
	
	quote_single = ''';
	quote_double = '"';
	
	/* Escape Sequences */
	/*escape_a = '\a';
	escape_b = '\b';
	escape_f = '\f';
	escape_n = '\n';
	escape_r = '\r';
	escape_t = '\t';
	escape_v = '\v';
	escape_slash = '\\';
	escape_single_quote = '\' ''';
	escape_double_quote = '\"';
	
	escape_sequence = '\a' | escape_b | escape_f | escape_n | escape_r | escape_t | escape_v | escape_slash*/
	
	
	digit_nonzero = ['1'..'9'];
	digit_decimal = ['0'..'9'];
	digit_octal = ['0'..'7'];
	digit_hex = ['0'..'9'] | ['A'..'F'] | ['a'..'f'];
	
	letter_lc = ['a'..'z'];
	letter_uc = ['A'..'Z'];
	letter  = letter_lc | letter_uc | '_';
	
	/*char_literal = [all - [eol + '\']];*/ /* disallow backslash, then allow appropriate escape sequences */
	char_escape = '\' ( 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\' );
	char_escape_sq = '\' ''';
	char_escape_dq = '\"';

Tokens
	whitespace = (' ' | tab | eol)+;
	
	/* Keywords */
	import = 'import';
	package = 'package';
	chan = 'chan';
	const = 'const';
	default = 'default';
	defer = 'defer';
	var = 'var';
	type = 'type';
	struct = 'struct';
	interface = 'interface';
	func = 'func';
	return = 'return';
	if = 'if';
	else = 'else';
	switch = 'switch';
	case = 'case';
	goto = 'goto';
	for = 'for';
	break = 'break';
	continue = 'continue';
	fallthrough = 'fallthrough';
	go = 'go';
	map = 'map';
	range = 'range';
	select = 'select';
	print = 'print';
	append = 'append';
	println = 'println';
	bool = 'bool';
	int = 'int';
	float64 = 'float64';
	rune = 'rune';
	string = 'string';
	
	/* Operators and Delimiters
	 * in order from the specs (easier to spot a missing one) */
	plus = '+';
	minus = '-';
	star = '*';
	slash = '/';
	percent = '%';
	amp = '&';
	pipe = '|';
	caret = '^';
	lshift = '<<';
	rshift = '>>';
	amp_caret = '&^';
	plus_eq = '+=';
	minus_eq = '-=';
	star_eq = '*=';
	slash_eq = '/=';
	percent_eq = '%=';
	amp_eq = '&=';
	pipe_eq = '|=';
	caret_eq = '^=';
	lshift_eq = '<<=';
	rshift_eq = '>>=';
	amp_caret_eq = '&^=';
	amp_amp = '&&';
	bar_bar = '||';
	larrow = '<-';
	plus_plus = '++';
	minus_minus = '--';
	eq_eq = '==';
	lt = '<';
	gt = '>';
	eq = '=';
	exclamation = '!';
	not_eq = '!=';
	lt_eq = '<=';
	gt_eq = '>=';
	colon_eq = ':=';
	elipsis = '...';
	paren_l = '(';
	paren_r = ')';
	square_l = '[';
	square_r = ']';
	brace_l = '{';
	brace_r = '}';
	comma = ',';
	dot = '.';
	semicolon = ';';
	colon = ':';
	
	/* Comments */
	comment = ('//' not_eol* eol)
				| ('/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/');

	/* Literals */
	lit_int  = '0' | digit_nonzero digit_decimal*;
	lit_octal = '0' digit_octal+;
	lit_hex = '0x' digit_hex+;
	lit_float = ('0' | digit_nonzero digit_decimal*)? '.' digit_decimal*;
	lit_rune = quote_single (not_backslash | char_escape | char_escape_sq)  quote_single;
	lit_raw = quote_single [all - ''']*  quote_single;
	lit_interpreted = quote_double (not_backslash | char_escape | char_escape_dq) quote_double;
	
	/* Identifiers*/
	id = letter (letter | digit_decimal)*;

Ignored Tokens
	whitespace, comment; /*_line, comment_block;*/

Productions
	cst_grammar = lit_int;
/* 	cst_grammar {->ast_grammar}
					= cst_dec* cst_stm*  {-> New ast_grammar([cst_dec.ast_dec], [cst_stm.ast_stm])};
	
	cst_dec {->ast_dec}
					= {int} var id colon int semicolon {-> New ast_dec.int(id)}
					| {float} var id colon float semicolon {-> New ast_dec.float(id)};
	
	cst_stm {->ast_stm}
					= {assign} cst_assign {-> cst_assign.ast_stm}
					| {if} cst_if {-> cst_if.ast_stm}
					| {while} cst_while {-> cst_while.ast_stm}
					| {read} cst_read {-> cst_read.ast_stm}
					| {print} cst_print {-> cst_print.ast_stm};
	
	cst_assign {->ast_stm}
					= id equal cst_exp semicolon {-> New ast_stm.assign(id, cst_exp.ast_exp)};
	
	cst_if {->ast_stm}
					= {ifone} if cst_exp then cst_stm* endif
						{-> New ast_stm.if(cst_exp.ast_exp, [cst_stm.ast_stm], [])}
					| {ifelse} if cst_exp then [first]:cst_stm* else [second]:cst_stm* endif
						{-> New ast_stm.if(cst_exp.ast_exp, [first.ast_stm], [second.ast_stm])};
	
	cst_while {->ast_stm}
					= while cst_exp do cst_stm* done {-> New ast_stm.while(cst_exp.ast_exp, [cst_stm.ast_stm])};
	
	cst_read {->ast_stm}
					= read id semicolon {-> New ast_stm.read(id)};
	
	cst_print {->ast_stm}
					= print cst_exp semicolon {-> New ast_stm.print(cst_exp.ast_exp)};
	
	cst_exp {->ast_exp}
					= {factor} cst_factor {-> cst_factor.ast_exp}
					| {add} cst_exp plus cst_factor {-> New ast_exp.addition(cst_exp.ast_exp, cst_factor.ast_exp)}
					| {sub} cst_exp minus cst_factor {-> New ast_exp.subtraction(cst_exp.ast_exp, cst_factor.ast_exp)};
	
	cst_factor {->ast_exp}
					= {term} cst_term {-> cst_term.ast_exp}
					| {mul} cst_factor star cst_term {-> New ast_exp.multiplication(cst_factor.ast_exp, cst_term.ast_exp)}
					| {div} cst_factor slash cst_term {-> New ast_exp.division(cst_factor.ast_exp, cst_term.ast_exp)};
					
	cst_term {->ast_exp}
					= {negation} minus cst_term {-> New ast_exp.negation(cst_term.ast_exp)}
					| {paren} lparen cst_exp rparen {-> cst_exp.ast_exp}
					| {id} id {-> New ast_exp.variable(id)}
					| {int} int_lit {-> New ast_exp.int_lit(int_lit)}
					| {float} float_lit {-> New ast_exp.float_lit(float_lit)};

Abstract Syntax Tree
	ast_grammar = [declarations]:ast_dec* [statements]:ast_stm*;
	
	ast_dec = {int} id
				| {float} id;
	
	ast_stm = {assign} [variable]:id [value]:ast_exp
				| {if} [condition]:ast_exp [true]:ast_stm* [false]:ast_stm*
				| {while} [condition]:ast_exp [body]:ast_stm*
				| {read} id
				| {print} ast_exp;
	
	ast_exp = {addition} [left]:ast_exp [right]:ast_exp
				| {subtraction} [left]:ast_exp [right]:ast_exp
				| {multiplication} [left]:ast_exp [right]:ast_exp
				| {division} [left]:ast_exp [right]:ast_exp
				| {negation} ast_exp
				| {variable} id
				| {int_lit} int_lit
				| {float_lit} float_lit;
*/
