Package golite;

/* https://golang.org/ref/spec */

Helpers
	/* regular expression matching all valid 16-bit characters */
	/*any = [0..0xFFFF];*/
	all = [0..127];
 	tab   = 9;
	cr    = 13;
	lf    = 10;
	eol   = cr | lf | cr lf;
	not_eol = [all - [cr + lf]];
	not_star = [all - '*'];
	not_backslash = [all - '\'];
	not_star_slash = [not_star - '/'];
	
	quote_single = ''';
	quote_double = '"';
	quote_back = '`';
	
	digit_nonzero = ['1'..'9'];
	digit_decimal = ['0'..'9'];
	digit_octal = ['0'..'7'];
	digit_hex = ['0'..'9'] | ['A'..'F'] | ['a'..'f'];
	
	letter_lc = ['a'..'z'];
	letter_uc = ['A'..'Z'];
	letter  = letter_lc | letter_uc | '_';
	
	/*char_literal = [all - [eol + '\']];*/ /* disallow backslash, then allow appropriate escape sequences */
	char_escape = '\' ( 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\' );
	char_escape_sq = '\' ''';
	char_escape_dq = '\"';

Tokens
	whitespace = (' ' | tab)+;
	eol = eol;

	/* Keywords */
	import = 'import';
	package = 'package';
	chan = 'chan';
	const = 'const';
	default = 'default';
	defer = 'defer';
	var = 'var';
	type = 'type';
	struct = 'struct';
	interface = 'interface';
	func = 'func';
	return = 'return';
	if = 'if';
	else = 'else';
	switch = 'switch';
	case = 'case';
	goto = 'goto';
	for = 'for';
	break = 'break';
	continue = 'continue';
	fallthrough = 'fallthrough';
	go = 'go';
	map = 'map';
	range = 'range';
	select = 'select';
	print = 'print';
	append = 'append';
	println = 'println';
	bool = 'bool';
	int = 'int';
	float64 = 'float64';
	rune = 'rune';
	string = 'string';
	
	/* Operators and Delimiters
	 * in order from the specs (easier to spot a missing one) */
	plus = '+';
	minus = '-';
	star = '*';
	slash = '/';
	percent = '%';
	amp = '&';
	pipe = '|';
	caret = '^';
	lshift = '<<';
	rshift = '>>';
	amp_caret = '&^';
	plus_eq = '+=';
	minus_eq = '-=';
	star_eq = '*=';
	slash_eq = '/=';
	percent_eq = '%=';
	amp_eq = '&=';
	pipe_eq = '|=';
	caret_eq = '^=';
	lshift_eq = '<<=';
	rshift_eq = '>>=';
	amp_caret_eq = '&^=';
	amp_amp = '&&';
	bar_bar = '||';
	larrow = '<-';
	plus_plus = '++';
	minus_minus = '--';
	eq_eq = '==';
	lt = '<';
	gt = '>';
	eq = '=';
	exclamation = '!';
	not_eq = '!=';
	lt_eq = '<=';
	gt_eq = '>=';
	colon_eq = ':=';
	elipsis = '...';
	paren_l = '(';
	paren_r = ')';
	square_l = '[';
	square_r = ']';
	brace_l = '{';
	brace_r = '}';
	comma = ',';
	dot = '.';
	semicolon = ';';
	colon = ':';

	/* Comments
	 * Single line comments go up to the EOL, but don't include the EOL token
	 * because it needs to be separate for semicolon insertion */
	comment = ('//' not_eol*)
				| ('/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/');

	/* Literals */
	lit_int  = '0' | digit_nonzero digit_decimal*;
	lit_octal = '0' digit_octal+; /* + because a single 0 should be tagged as int */
	lit_hex = '0x' digit_hex+;
	lit_float = ('0' | digit_nonzero digit_decimal*)? '.' digit_decimal*;
	lit_rune        = quote_single ([not_backslash - quote_single] | char_escape | char_escape_sq)  quote_single;
	lit_raw         = quote_back [all - quote_back]*  quote_back;
	lit_interpreted = quote_double ([not_backslash - quote_double] | char_escape | char_escape_dq)* quote_double;

	/* Identifiers*/
	id = letter (letter | digit_decimal)*;

Ignored Tokens
	/* Changes here probably also require changes in GoLexer.java */
	whitespace, eol, comment;

Productions
	program = package_dec declaration*
		{-> New program(package_dec.id, [declaration])};

	package_dec {-> id} = package id semicolon {-> id};

	declaration =
		  {variable} var variable_specs semicolon
			{-> New declaration.variable([variable_specs.variable_spec])}
		| {type} type type_specs semicolon
			{-> New declaration.type([type_specs.type_spec])}
		| {function} func id paren_l func_param_list paren_r type_exp? block
			{-> New declaration.function(id, [func_param_list.func_param], type_exp, [block.stm])}
		| {empty} semicolon
			{-> New declaration.empty()}
	;

	/* Variable declarations */
	variable_specs {-> variable_spec*} =
		  {single_spec} variable_spec
			{-> [variable_spec]}
		| {multi_spec} paren_l variable_spec_with_semicolon* paren_r
			{-> [variable_spec_with_semicolon.variable_spec]}
	;

	variable_spec_with_semicolon {-> variable_spec} =
		variable_spec semicolon {-> variable_spec};

	variable_spec =
		  {no_expr} id_list type_exp
			{-> New variable_spec.typed([id_list.id], type_exp, [])}
		| {with_expr} id_list type_exp eq exp_list
			{-> New variable_spec.typed([id_list.id], type_exp, [exp_list.exp])}
		| {with_expr_no_type} id_list eq exp_list
			{-> New variable_spec.untyped([id_list.id], [exp_list.exp])}
	;

	id_list {-> id*} = id id_list_tail* {-> [id, id_list_tail.id]};

	id_list_tail {-> id} = comma id {-> id};

	exp_list {-> exp*} = exp exp_list_tail* {-> [exp, exp_list_tail.exp]};

	exp_list_tail {-> exp} = comma exp {-> exp};

	/* Type declarations */
	type_specs {-> type_spec*} =
		  {single_spec} type_spec
			{-> [type_spec]}
		| {multi_spec} paren_l type_spec_with_semicolon* paren_r
			{-> [type_spec_with_semicolon.type_spec]}
	;

	type_spec_with_semicolon {-> type_spec} = type_spec semicolon {-> type_spec};

	type_spec = id type_exp;

	/* Function declarations */
	func_param_list {-> func_param*} =
		  {nonempty} func_param func_param_list_tail*
				{-> [func_param, func_param_list_tail.func_param]}
		| {empty} {-> []}
	;

	func_param = id_list type_exp {-> New func_param([id_list.id], type_exp)};

	func_param_list_tail {-> func_param} = comma func_param {-> func_param};

	variable_spec_list_tail {-> variable_spec} =
		comma variable_spec {-> variable_spec};

	/* Types */
	type_exp =
		  {base} base_type
			{-> base_type.type_exp}
		| {alias} id
			{-> New type_exp.alias(id)}
		| {struct} struct brace_l field_dec* brace_r
			{-> New type_exp.struct([field_dec])}
		| {slice} square_l square_r type_exp
			{-> New type_exp.slice(type_exp)}
		| {array} square_l lit_int square_r type_exp
			{-> New type_exp.array(lit_int, type_exp)}
		| {recurse} paren_l type_exp paren_r
			{-> type_exp}
	;

	base_type {-> type_exp} =
		  {int} int
			{-> New type_exp.int()}
		| {float64} float64
			{-> New type_exp.float64()}
		| {bool} bool
			{-> New type_exp.bool()}
		| {rune} rune
			{-> New type_exp.rune()}
		| {string} string
			{-> New type_exp.string()}
	;

	field_dec = id_list type_exp semicolon
		{-> New field_dec([id_list.id], type_exp)};

	/* Statements */
	stm =
		  {simple_form} simple_stm {-> simple_stm.stm}
		| {variable_dec} var variable_specs semicolon
			{-> New stm.variable_dec([variable_specs.variable_spec])}
		| {type_dec} type type_specs semicolon
			{-> New stm.type_dec([type_specs.type_spec])}
		| {print} print_op paren_l exp_list_star paren_r semicolon
			{-> New stm.print(print_op, [exp_list_star.exp])}
		| {return} return exp? semicolon {-> New stm.return(exp)}
		| {if} if_stm {-> if_stm.stm}
		| {switch} switch simple_stm? exp? brace_l switch_clause* brace_r
			{-> New stm.switch(simple_stm.stm, exp, [switch_clause])}
		| {for} for_stm {-> for_stm.stm}
		| {break} break semicolon {-> New stm.break()}
		| {continue} continue semicolon {-> New stm.continue()}
	;

	simple_stm {-> stm} = bare_simple_stm semicolon {-> bare_simple_stm.stm};

	bare_simple_stm {-> stm} =
		  {empty} {-> New stm.empty()}
		| {expression} exp {-> New stm.expression(exp)}
		| {assign} lvalue_list eq exp_list
			{-> New stm.assign([lvalue_list.exp], [exp_list.exp])}
		| {op_assign} lvalue assign_op exp
			{-> New stm.op_assign(lvalue.exp, assign_op, exp)}
		/* Ensure the lvalue expressions are id's in weeding! */
		| {short_var_dec} lvalue_list colon_eq exp_list
			{-> New stm.short_variable_dec([lvalue_list.exp], [exp_list.exp])}
		| {inc_dec} lvalue postfix_op
			{-> New stm.inc_dec(lvalue.exp, postfix_op)}
	;

	if_stm {->stm} =
		  {if} if simple_stm? exp block
			{-> New stm.if(simple_stm.stm, exp, [block.stm], [])}
		| {if_else} if simple_stm? exp [if_block]:block else [else_block]:block
			{-> New stm.if(simple_stm.stm, exp, [if_block.stm], [else_block.stm])}
		| {if_else_if} if simple_stm? exp block else if_stm
			{-> New stm.if(simple_stm.stm, exp, [block.stm], [if_stm.stm])}
	;

	switch_clause =
		  {expression} case exp_list colon stm*
			{-> New switch_clause.conditional([exp_list.exp], [stm])}
		| {default} default colon stm*
			{-> New switch_clause.default([stm])}
	;

	for_stm {->stm} =
		  {infinite_loop} for block {-> New stm.for(Null, Null, Null, [block.stm])}
		| {while_loop} for exp block {-> New stm.for(Null, exp, Null, [block.stm])}
		| {full_loop} for [init]:simple_stm exp semicolon [post]:bare_simple_stm block
			{-> New stm.for(init.stm, exp, post.stm, [block.stm])}
	;

	block {-> stm*} = brace_l stm* brace_r {-> [stm]};

	exp_list_star {-> exp*} =
		  {empty} {-> []}
		| {non_empty} exp_list {-> [exp_list.exp]}
	;

	print_op =
		  {simple} print {-> New print_op.simple()}
		| {line} println {-> New print_op.line()}
	;

	postfix_op =
		  {inc} plus_plus {-> New postfix_op.inc()}
		| {dec} minus_minus {-> New postfix_op.dec()}
	;

	assign_op =
		  {plus_eq} plus_eq {-> New assign_op.plus()}
		| {minus_eq} minus_eq {-> New assign_op.minus()}
		| {star_eq} star_eq {-> New assign_op.star()}
		| {slash_eq} slash_eq {-> New assign_op.slash()}
		| {percent_eq} percent_eq {-> New assign_op.percent()}
		| {amp_eq} amp_eq {-> New assign_op.amp()}
		| {pipe_eq} pipe_eq {-> New assign_op.pipe()}
		| {caret_eq} caret_eq {-> New assign_op.caret()}
		| {lshift_eq} lshift_eq {-> New assign_op.lshift()}
		| {rshift_eq} rshift_eq {-> New assign_op.rshift()}
		| {amp_caret_eq} amp_caret_eq {-> New assign_op.amp_caret()}
	;

	cmp_op {-> binary_op} =
		  {eq} eq_eq {-> New binary_op.eq()}
		| {gt} gt {-> New binary_op.gt()}
		| {lt} lt {-> New binary_op.lt()}
		| {gt_eq} gt_eq {-> New binary_op.gt_eq()}
		| {lt_eq} lt_eq {-> New binary_op.lt_eq()}
	;

	term_op {-> binary_op} =
		  {plus} plus {-> New binary_op.plus()}
		| {minus} minus {-> New binary_op.minus()}
		| {pipe} pipe {-> New binary_op.pipe()}
		| {caret} caret {-> New binary_op.caret()}
	;

	factor_op {-> binary_op} =
		  {star} star {-> New binary_op.star()}
		| {slash} slash {-> New binary_op.slash()}
		| {percent} percent {-> New binary_op.percent()}
		| {lshift} lshift {-> New binary_op.lshift()}
		| {rshift} rshift {-> New binary_op.rshift()}
		| {amp} amp {-> New binary_op.amp()}
		| {amp_caret} amp_caret {-> New binary_op.amp_caret()}
	;

	unary_op =
		  {plus} plus {-> New unary_op.plus()}
		| {minus} minus {-> New unary_op.minus()}
		| {exclamation} exclamation {-> New unary_op.exclamation()}
		| {caret} caret {-> New unary_op.caret()}
	;

	/* Expressions */
	exp =
		  {logical_or} exp bar_bar and_exp {-> New exp.binary(exp, New binary_op.logical_or(), and_exp.exp)}
		| {base} and_exp {-> and_exp.exp}
	;

	and_exp {-> exp} =
		  {logical_and} and_exp amp_amp comparison_exp {-> New exp.binary(and_exp.exp, New binary_op.logical_and(), comparison_exp.exp)}
		| {base} comparison_exp {-> comparison_exp.exp}
	;

	comparison_exp {-> exp} =
		  {comparison} comparison_exp cmp_op term {-> New exp.binary(comparison_exp.exp, cmp_op.binary_op, term.exp)}
		| {base} term {-> term.exp}
	;

	term {-> exp} =
		  {term} term term_op factor {-> New exp.binary(term.exp, term_op.binary_op, factor.exp)}
		| {base} factor {-> factor.exp}
	;

	factor {-> exp} =
		  {factor} factor factor_op unary_exp {-> New exp.binary(factor.exp, factor_op.binary_op, unary_exp.exp)}
		| {base} unary_exp {-> unary_exp.exp}
	;

	unary_exp {-> exp} =
		  {unary} unary_op unary_exp {-> New exp.unary(unary_op, unary_exp.exp)}
		| {primary} primary_exp {-> primary_exp.exp}
	;

	primary_exp {-> exp} =
		  {recurse} paren_l exp paren_r
			{-> exp}
		| {lvalue} lvalue
			{-> lvalue.exp}
		| {lit_int} lit_int
			{-> New exp.lit_int(lit_int)}
		| {lit_float} lit_float
			{-> New exp.lit_float(lit_float)}
		| {lit_hex} lit_hex
			{-> New exp.lit_hex(lit_hex)}
		| {lit_octal} lit_octal
			{-> New exp.lit_octal(lit_octal)}
		| {lit_interpreted} lit_interpreted
			{-> New exp.lit_interpreted(lit_interpreted)}
		| {lit_raw} lit_raw
			{-> New exp.lit_raw(lit_raw)}
		| {lit_rune} lit_rune
			{-> New exp.lit_rune(lit_rune)}
		| {function_call} id paren_l exp_list paren_r
			{-> New exp.function_call(id, [exp_list.exp])}
		| {base_type_cast} base_type paren_l exp paren_r
			{-> New exp.base_type_cast(base_type.type_exp, exp)}
		| {append} append paren_l id comma exp paren_r
			{-> New exp.append(id, exp)}
	;

	// TODO: Fairly certain the recursive use of lvalue here is okay based on
	// http://golang.org/ref/spec#Address_operators but I'm not positive
	lvalue {-> exp} =
		  {variable} id
			{-> New exp.variable(id)}
		| {array_access} lvalue square_l exp square_r
			{-> New exp.array_access(lvalue.exp, exp)}
		| {field_access} lvalue dot id
			{-> New exp.field_access(lvalue.exp, id)}
	;

	lvalue_list {-> exp*} = lvalue lvalue_list_tail*
		{-> [lvalue.exp, lvalue_list_tail.exp]};

	lvalue_list_tail {-> exp} = comma lvalue {-> lvalue.exp};

Abstract Syntax Tree
	program = [package_name]:id [declarations]:declaration*;

	declaration =
		  {variable} variable_spec*
		| {type} type_spec*
		| {function} id func_param* [return_type]:type_exp? stm*
		| {empty}
	;

	variable_spec =
		  {typed} id+ type_exp exp*
		| {untyped} id+ exp+
	;

	type_spec = id type_exp;

	func_param = id+ type_exp;

	type_exp =
		  {alias} id
		| {int}
		| {float64}
		| {bool}
		| {rune}
		| {string}
		| {struct} field_dec*
		| {slice} type_exp
		| {array} lit_int type_exp
	;

	field_dec = id+ type_exp;

	stm =
		  {empty}
		| {expression} exp
		| {assign} [lvalue]:exp+ exp+
		| {op_assign} [lvalue]:exp assign_op exp
		| {inc_dec} exp postfix_op
		| {short_variable_dec} [ids]:exp+ exp+
		| {variable_dec} variable_spec+
		| {type_dec} type_spec+
		| {print} print_op exp*
		| {return} exp?
		| {if} stm? exp [if_block]:stm* [else_block]:stm*
		| {switch} stm? exp? switch_clause*
		| {for} [init]:stm? exp? [post]:stm? stm*
		| {break}
		| {continue}
	;

	switch_clause = {conditional} exp+ stm* | {default} stm*;

	print_op = {simple} | {line};

	postfix_op = {inc} | {dec};

	assign_op =
		  {plus}
		| {minus}
		| {star}
		| {slash}
		| {percent}
		| {amp}
		| {pipe}
		| {caret}
		| {lshift}
		| {rshift}
		| {amp_caret}
	;

	binary_op =
		  {logical_or}
		| {logical_and}
		| {eq}
		| {gt}
		| {lt}
		| {gt_eq}
		| {lt_eq}
		| {plus}
		| {minus}
		| {star}
		| {slash}
		| {percent}
		| {amp}
		| {pipe}
		| {caret}
		| {lshift}
		| {rshift}
		| {amp_caret}
	;

	unary_op = {plus} | {minus} | {exclamation} | {caret} ;

	exp =
		  {variable} id
		| {array_access} [array]:exp [index]:exp
		| {field_access} exp id
		| {lit_int} lit_int
		| {lit_float} lit_float
		| {lit_hex} lit_hex
		| {lit_octal} lit_octal
		| {lit_interpreted} lit_interpreted
		| {lit_raw} lit_raw
		| {lit_rune} lit_rune
		| {function_call} id exp*
		| {base_type_cast} type_exp exp
		| {append} id exp
		| {binary} [left]:exp binary_op [right]:exp
		| {unary} unary_op exp
	;
